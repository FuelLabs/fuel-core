use self::mdns::MdnsWorker;
use futures::FutureExt;
use futures_timer::Delay;
use libp2p::{
    core::{
        connection::{ConnectionId, ListenerId},
        ConnectedPoint,
    },
    kad::{handler::KademliaHandlerProto, store::MemoryStore, Kademlia, QueryId},
    swarm::{
        DialError, IntoProtocolsHandler, NetworkBehaviour, NetworkBehaviourAction, PollParameters,
        ProtocolsHandler,
    },
    Multiaddr, PeerId,
};
use std::{
    collections::VecDeque,
    io,
    task::{Context, Poll},
    time::Duration,
};
mod discovery_config;
mod mdns;
pub use discovery_config::DiscoveryConfig;

const SIXTY_SECONDS: Duration = Duration::from_secs(60);

/// Event generated by the `DiscoveryBehaviour`.
#[derive(Debug)]
pub enum DiscoveryOutEvent {
    /// Event that notifies that we connected to the node with the given peer id.
    Connected(PeerId),

    /// Event that notifies that we disconnected with the node with the given peer id.
    Disconnected(PeerId),
}

/// NetworkBehavior for discovery of nodes
pub struct Discovery {
    local_peer_id: PeerId,

    /// predefined list of nodes and their addresses
    predefined_nodes: Vec<(PeerId, Multiaddr)>,

    /// events to report to the swarm
    events: VecDeque<DiscoveryOutEvent>,

    /// for discovery on local network, optionally available
    mdns: MdnsWorker,

    // Kademlia related
    kademlia: Kademlia<MemoryStore>,
    next_kad_random_query: Option<Delay>,
    connected_peers_count: u64,
    max_peers_connected: u64,
    duration_to_next_kad: Duration,
}

impl NetworkBehaviour for Discovery {
    type ProtocolsHandler = KademliaHandlerProto<QueryId>;
    type OutEvent = DiscoveryOutEvent;

    // Initializes new handler on a new opened connection
    fn new_handler(&mut self) -> Self::ProtocolsHandler {
        // in our case we just return KademliaHandlerProto
        self.kademlia.new_handler()
    }

    // receives events from KademliaHandler and pass it down to kademlia
    fn inject_event(
        &mut self,
        peer_id: PeerId,
        connection: ConnectionId,
        event: <<Self::ProtocolsHandler as IntoProtocolsHandler>::Handler as ProtocolsHandler>::OutEvent,
    ) {
        self.kademlia.inject_event(peer_id, connection, event);
    }

    fn poll(
        &mut self,
        cx: &mut Context<'_>,
        params: &mut impl PollParameters,
    ) -> Poll<NetworkBehaviourAction<Self::OutEvent, Self::ProtocolsHandler>> {
        if let Some(next_event) = self.events.pop_front() {
            return Poll::Ready(NetworkBehaviourAction::GenerateEvent(next_event));
        }

        // if random walk is enabled poll the stream that will fire when random walk is scheduled
        if let Some(next_kad_random_query) = self.next_kad_random_query.as_mut() {
            while let Poll::Ready(_) = next_kad_random_query.poll_unpin(cx) {
                if self.connected_peers_count < self.max_peers_connected {
                    let random_peer_id = PeerId::random();
                    self.kademlia.get_closest_peers(random_peer_id);
                }

                // restart the delay to next random walk
                *next_kad_random_query = Delay::new(self.duration_to_next_kad);
                // duration to next random walk should either be exponentially bigger than the previous
                // or at max 60 seconds
                self.duration_to_next_kad =
                    std::cmp::min(self.duration_to_next_kad * 2, SIXTY_SECONDS);
            }
        }

        while let Poll::Ready(kademlia_event) = self.kademlia.poll(cx, params) {
            match kademlia_event {
                NetworkBehaviourAction::GenerateEvent(event) => match event {
                    _ => {}
                },

                NetworkBehaviourAction::Dial { handler, opts } => {
                    return Poll::Ready(NetworkBehaviourAction::Dial { handler, opts });
                }
                NetworkBehaviourAction::CloseConnection {
                    peer_id,
                    connection,
                } => {
                    return Poll::Ready(NetworkBehaviourAction::CloseConnection {
                        peer_id,
                        connection,
                    });
                }
                NetworkBehaviourAction::NotifyHandler {
                    peer_id,
                    handler,
                    event,
                } => {
                    return Poll::Ready(NetworkBehaviourAction::NotifyHandler {
                        peer_id,
                        handler,
                        event,
                    })
                }
                NetworkBehaviourAction::ReportObservedAddr { address, score } => {
                    return Poll::Ready(NetworkBehaviourAction::ReportObservedAddr {
                        address,
                        score,
                    })
                }
            }
        }

        while let Poll::Ready(mdns_event) = self.mdns.poll(cx, params) {
            match mdns_event {
                NetworkBehaviourAction::ReportObservedAddr { address, score } => {
                    return Poll::Ready(NetworkBehaviourAction::ReportObservedAddr {
                        address,
                        score,
                    })
                }
                NetworkBehaviourAction::CloseConnection {
                    peer_id,
                    connection,
                } => {
                    return Poll::Ready(NetworkBehaviourAction::CloseConnection {
                        peer_id,
                        connection,
                    })
                }
                _ => {}
            }
        }

        if let Some(next_event) = self.events.pop_front() {
            return Poll::Ready(NetworkBehaviourAction::GenerateEvent(next_event));
        }

        Poll::Pending
    }

    // todo: implement this
    fn addresses_of_peer(&mut self, _: &PeerId) -> Vec<Multiaddr> {
        todo!()
    }

    fn inject_connection_established(
        &mut self,
        peer_id: &PeerId,
        connection_id: &ConnectionId,
        endpoint: &libp2p::core::ConnectedPoint,
        failed_addresses: Option<&Vec<Multiaddr>>,
    ) {
        self.connected_peers_count += 1;

        self.kademlia.inject_connection_established(
            peer_id,
            connection_id,
            endpoint,
            failed_addresses,
        )
    }

    fn inject_connected(&mut self, peer_id: &PeerId) {
        self.events
            .push_back(DiscoveryOutEvent::Connected(*peer_id));

        self.kademlia.inject_connected(peer_id);
    }

    fn inject_connection_closed(
        &mut self,
        _peer_id: &PeerId,
        _connection_id: &ConnectionId,
        _connection_point: &ConnectedPoint,
        _handler: <Self::ProtocolsHandler as IntoProtocolsHandler>::Handler,
    ) {
        self.connected_peers_count -= 1;
        // no need to pass it to kademlia.inject_connection_closed() since it does nothing
    }

    fn inject_disconnected(&mut self, peer_id: &PeerId) {
        self.events
            .push_back(DiscoveryOutEvent::Disconnected(*peer_id));

        self.kademlia.inject_disconnected(peer_id)
    }

    fn inject_new_external_addr(&mut self, addr: &Multiaddr) {
        self.kademlia.inject_new_external_addr(addr)
    }

    fn inject_expired_listen_addr(&mut self, id: ListenerId, addr: &Multiaddr) {
        self.kademlia.inject_expired_listen_addr(id, addr);
    }

    fn inject_dial_failure(
        &mut self,
        peer_id: Option<PeerId>,
        handler: Self::ProtocolsHandler,
        err: &DialError,
    ) {
        self.kademlia.inject_dial_failure(peer_id, handler, err)
    }

    fn inject_new_listen_addr(&mut self, id: ListenerId, addr: &Multiaddr) {
        self.kademlia.inject_new_listen_addr(id, addr)
    }

    fn inject_listener_error(&mut self, id: ListenerId, err: &(dyn std::error::Error + 'static)) {
        self.kademlia.inject_listener_error(id, err)
    }

    fn inject_listener_closed(&mut self, id: ListenerId, reason: Result<(), &io::Error>) {
        self.kademlia.inject_listener_closed(id, reason)
    }
}

#[cfg(test)]
mod tests {
    use super::{Discovery, DiscoveryConfig, DiscoveryOutEvent};
    use futures::StreamExt;
    use libp2p::{
        core, identity::Keypair, noise, swarm::SwarmEvent, yamux, Multiaddr, Swarm, Transport,
    };
    use std::{
        collections::{HashSet, VecDeque},
        task::Poll,
    };

    /// helper function for building Discovery Behaviour for testing
    fn build_fuel_discovery(peer: Option<Multiaddr>) -> (Swarm<Discovery>, Multiaddr) {
        let keypair = Keypair::generate_secp256k1();

        let noise_keys = noise::Keypair::<noise::X25519Spec>::new()
            .into_authentic(&keypair)
            .unwrap();

        let transport = core::transport::MemoryTransport
            .upgrade(core::upgrade::Version::V1)
            .authenticate(noise::NoiseConfig::xx(noise_keys).into_authenticated())
            .multiplex(yamux::YamuxConfig::default())
            .boxed();

        let behaviour = {
            let mut config = DiscoveryConfig::new(keypair.public(), "test_network".into());
            config.discovery_limit(50).with_predefined_nodes(peer);

            config.finish()
        };

        let listen_addr: Multiaddr = format!("/memory/{}", rand::random::<u64>())
            .parse()
            .unwrap();

        let mut swarm = Swarm::new(transport, behaviour, keypair.public().to_peer_id());

        swarm.listen_on(listen_addr.clone()).unwrap();

        (swarm, listen_addr)
    }

    #[test]
    fn discovery_works() {
        todo!()
    }
}
