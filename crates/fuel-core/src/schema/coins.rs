use std::collections::HashSet;

use crate::{
    coins_query::{
        random_improve,
        CoinsQueryError,
        SpendQuery,
    },
    fuel_core_graphql_api::{
        query_costs,
        IntoApiResult,
    },
    graphql_api::{
        api_service::ConsensusProvider,
        database::ReadView,
        indexation::coins_to_spend::IndexedCoinType,
        ports::CoinsToSpendIndexIter,
        storage::coins::{
            CoinsToSpendIndexKey,
            COIN_FOREIGN_KEY_LEN,
            MESSAGE_FOREIGN_KEY_LEN,
        },
    },
    query::asset_query::AssetSpendTarget,
    schema::{
        scalars::{
            Address,
            AssetId,
            Nonce,
            UtxoId,
            U16,
            U32,
            U64,
        },
        ReadViewProvider,
    },
};
use async_graphql::{
    connection::{
        Connection,
        EmptyFields,
    },
    Context,
};
use fuel_core_services::yield_stream::StreamYieldExt;
use fuel_core_storage::{
    codec::primitive::utxo_id_to_bytes,
    Error as StorageError,
    Result as StorageResult,
};
use fuel_core_types::{
    entities::coins::{
        self,
        coin::Coin as CoinModel,
        message_coin::{
            self,
            MessageCoin as MessageCoinModel,
        },
        CoinId,
    },
    fuel_tx::{
        self,
        TxId,
    },
    fuel_types,
};
use futures::Stream;
use itertools::Itertools;
use rand::Rng;
use tokio_stream::StreamExt;

type CoinsToSpendIndexEntry = (CoinsToSpendIndexKey, IndexedCoinType);

pub struct Coin(pub(crate) CoinModel);

#[async_graphql::Object]
impl Coin {
    async fn utxo_id(&self) -> UtxoId {
        self.0.utxo_id.into()
    }

    async fn owner(&self) -> Address {
        self.0.owner.into()
    }

    async fn amount(&self) -> U64 {
        self.0.amount.into()
    }

    async fn asset_id(&self) -> AssetId {
        self.0.asset_id.into()
    }

    /// TxPointer - the height of the block this coin was created in
    async fn block_created(&self) -> U32 {
        u32::from(self.0.tx_pointer.block_height()).into()
    }

    /// TxPointer - the index of the transaction that created this coin
    async fn tx_created_idx(&self) -> U16 {
        self.0.tx_pointer.tx_index().into()
    }
}

impl From<CoinModel> for Coin {
    fn from(value: CoinModel) -> Self {
        Coin(value)
    }
}

pub struct MessageCoin(pub(crate) MessageCoinModel);

#[async_graphql::Object]
impl MessageCoin {
    async fn sender(&self) -> Address {
        self.0.sender.into()
    }

    async fn recipient(&self) -> Address {
        self.0.recipient.into()
    }

    async fn nonce(&self) -> Nonce {
        self.0.nonce.into()
    }

    async fn amount(&self) -> U64 {
        self.0.amount.into()
    }

    #[graphql(complexity = "query_costs().storage_read")]
    async fn asset_id(&self, ctx: &Context<'_>) -> AssetId {
        let params = ctx
            .data_unchecked::<ConsensusProvider>()
            .latest_consensus_params();

        let base_asset_id = *params.base_asset_id();
        base_asset_id.into()
    }

    async fn da_height(&self) -> U64 {
        self.0.da_height.0.into()
    }
}

impl From<MessageCoinModel> for MessageCoin {
    fn from(value: MessageCoinModel) -> Self {
        MessageCoin(value)
    }
}

/// The schema analog of the [`coins::CoinType`].
#[derive(async_graphql::Union)]
pub enum CoinType {
    /// The regular coins generated by the transaction output.
    Coin(Coin),
    /// The bridged coin from the DA layer.
    MessageCoin(MessageCoin),
}

impl From<coins::CoinType> for CoinType {
    fn from(value: coins::CoinType) -> Self {
        match value {
            coins::CoinType::Coin(coin) => CoinType::Coin(coin.into()),
            coins::CoinType::MessageCoin(coin) => CoinType::MessageCoin(coin.into()),
        }
    }
}

#[derive(async_graphql::InputObject)]
struct CoinFilterInput {
    /// Returns coins owned by the `owner`.
    owner: Address,
    /// Returns coins only with `asset_id`.
    asset_id: Option<AssetId>,
}

#[derive(async_graphql::InputObject)]
pub struct SpendQueryElementInput {
    /// Identifier of the asset to spend.
    asset_id: AssetId,
    /// Target amount for the query.
    amount: U64,
    /// The maximum number of currencies for selection.
    max: Option<U32>,
}

#[derive(async_graphql::InputObject)]
pub struct ExcludeInput {
    /// Utxos to exclude from the selection.
    utxos: Vec<UtxoId>,
    /// Messages to exclude from the selection.
    messages: Vec<Nonce>,
}

pub struct ExcludedKeysAsBytes {
    coins: Vec<CoinOrMessageIdBytes>,
    messages: Vec<CoinOrMessageIdBytes>,
}

// The part of the `CoinsToSpendIndexKey` which is used to identify the coin or message in the
// OnChain database. We could consider using `CoinId`, but we do not need to re-create
// neither the `UtxoId` nor `Nonce` from the raw bytes.
#[derive(PartialEq)]
pub(crate) enum CoinOrMessageIdBytes {
    Coin([u8; COIN_FOREIGN_KEY_LEN]),
    Message([u8; MESSAGE_FOREIGN_KEY_LEN]),
}

impl CoinOrMessageIdBytes {
    pub(crate) fn from_utxo_id(utxo_id: &fuel_tx::UtxoId) -> Self {
        Self::Coin(utxo_id_to_bytes(utxo_id))
    }

    pub(crate) fn from_nonce(nonce: &fuel_types::Nonce) -> Self {
        let mut arr = [0; MESSAGE_FOREIGN_KEY_LEN];
        arr.copy_from_slice(nonce.as_ref());
        Self::Message(arr)
    }
}

impl ExcludedKeysAsBytes {
    pub(crate) fn new(
        coins: Vec<CoinOrMessageIdBytes>,
        messages: Vec<CoinOrMessageIdBytes>,
    ) -> Self {
        Self { coins, messages }
    }

    pub(crate) fn coins(&self) -> &[CoinOrMessageIdBytes] {
        &self.coins
    }

    pub(crate) fn messages(&self) -> &[CoinOrMessageIdBytes] {
        &self.messages
    }
}

#[derive(Default)]
pub struct CoinQuery;

#[async_graphql::Object]
impl CoinQuery {
    /// Gets the coin by `utxo_id`.
    #[graphql(complexity = "query_costs().storage_read + child_complexity")]
    async fn coin(
        &self,
        ctx: &Context<'_>,
        #[graphql(desc = "The ID of the coin")] utxo_id: UtxoId,
    ) -> async_graphql::Result<Option<Coin>> {
        let query = ctx.read_view()?;
        query.coin(utxo_id.0).into_api_result()
    }

    /// Gets all unspent coins of some `owner` maybe filtered with by `asset_id` per page.
    #[graphql(complexity = "{\
        query_costs().storage_iterator\
        + (query_costs().storage_read + first.unwrap_or_default() as usize) * child_complexity \
        + (query_costs().storage_read + last.unwrap_or_default() as usize) * child_complexity\
    }")]
    async fn coins(
        &self,
        ctx: &Context<'_>,
        filter: CoinFilterInput,
        first: Option<i32>,
        after: Option<String>,
        last: Option<i32>,
        before: Option<String>,
    ) -> async_graphql::Result<Connection<UtxoId, Coin, EmptyFields, EmptyFields>> {
        let query = ctx.read_view()?;
        let owner: fuel_tx::Address = filter.owner.into();
        crate::schema::query_pagination(after, before, first, last, |start, direction| {
            let coins = query
                .owned_coins(&owner, (*start).map(Into::into), direction)
                .filter_map(|result| {
                    if let (Ok(coin), Some(filter_asset_id)) = (&result, &filter.asset_id)
                    {
                        if coin.asset_id != filter_asset_id.0 {
                            return None
                        }
                    }

                    Some(result)
                })
                .map(|res| res.map(|coin| (coin.utxo_id.into(), coin.into())));

            Ok(coins)
        })
        .await
    }

    /// For each `query_per_asset`, get some spendable coins(of asset specified by the query) owned by
    /// `owner` that add up at least the query amount. The returned coins can be spent.
    /// The number of coins is optimized to prevent dust accumulation.
    ///
    /// The query supports excluding and maximum the number of coins.
    ///
    /// Returns:
    ///     The list of spendable coins per asset from the query. The length of the result is
    ///     the same as the length of `query_per_asset`. The ordering of assets and `query_per_asset`
    ///     is the same.
    #[graphql(complexity = "query_costs().coins_to_spend")]
    async fn coins_to_spend(
        &self,
        ctx: &Context<'_>,
        #[graphql(desc = "The `Address` of the coins owner.")] owner: Address,
        #[graphql(desc = "\
            The list of requested assets` coins with asset ids, `target` amount the user wants \
            to reach, and the `max` number of coins in the selection. Several entries with the \
            same asset id are not allowed. The result can't contain more coins than `max_inputs`.")]
        mut query_per_asset: Vec<SpendQueryElementInput>,
        #[graphql(desc = "The excluded coins from the selection.")] excluded_ids: Option<
            ExcludeInput,
        >,
    ) -> async_graphql::Result<Vec<Vec<CoinType>>> {
        let params = ctx
            .data_unchecked::<ConsensusProvider>()
            .latest_consensus_params();
        let max_input = params.tx_params().max_inputs();

        let excluded_id_count = excluded_ids.as_ref().map_or(0, |exclude| {
            exclude.utxos.len().saturating_add(exclude.messages.len())
        });
        if excluded_id_count > max_input as usize {
            return Err(CoinsQueryError::TooManyExcludedId {
                provided: excluded_id_count,
                allowed: max_input,
            }
            .into());
        }

        let mut duplicate_checker = HashSet::with_capacity(query_per_asset.len());
        for query in &query_per_asset {
            let asset_id: fuel_tx::AssetId = query.asset_id.into();
            if !duplicate_checker.insert(asset_id) {
                return Err(CoinsQueryError::DuplicateAssets(asset_id).into());
            }
        }

        let owner: fuel_tx::Address = owner.0;

        // `coins_to_spend` exists to help select inputs for the transactions.
        // It doesn't make sense to allow the user to request more than the maximum number
        // of inputs.
        // TODO: To avoid breaking changes, we will truncate request for now.
        //  In the future, we should return an error if the input is too large.
        //  https://github.com/FuelLabs/fuel-core/issues/2343
        query_per_asset.truncate(max_input as usize);

        let read_view = ctx.read_view()?;
        let indexation_available = read_view.coins_to_spend_indexation_enabled;
        if indexation_available {
            coins_to_spend_with_cache(
                owner,
                query_per_asset,
                excluded_ids,
                max_input,
                read_view.as_ref(),
            )
            .await
        } else {
            let base_asset_id = params.base_asset_id();
            coins_to_spend_without_cache(
                owner,
                query_per_asset,
                excluded_ids,
                max_input,
                base_asset_id,
                read_view.as_ref(),
            )
            .await
        }
    }
}

async fn coins_to_spend_with_cache(
    owner: fuel_tx::Address,
    query_per_asset: Vec<SpendQueryElementInput>,
    excluded_ids: Option<ExcludeInput>,
    max_input: u16,
    db: &ReadView,
) -> async_graphql::Result<Vec<Vec<CoinType>>> {
    let mut all_coins = Vec::with_capacity(query_per_asset.len());

    let (excluded_utxo_id_bytes, excluded_nonce_bytes) = excluded_ids.map_or_else(
        || (vec![], vec![]),
        |exclude| {
            (
                exclude
                    .utxos
                    .into_iter()
                    .map(|utxo_id| CoinOrMessageIdBytes::from_utxo_id(&utxo_id.0))
                    .collect(),
                exclude
                    .messages
                    .into_iter()
                    .map(|nonce| CoinOrMessageIdBytes::from_nonce(&nonce.0))
                    .collect(),
            )
        },
    );

    let excluded = ExcludedKeysAsBytes::new(excluded_utxo_id_bytes, excluded_nonce_bytes);

    for asset in query_per_asset {
        let asset_id = asset.asset_id.0;
        let total_amount = asset.amount.0;
        let max = asset
            .max
            .and_then(|max| u16::try_from(max.0).ok())
            .unwrap_or(max_input)
            .min(max_input);

        let selected_stream = futures::stream::iter(
            select_coins_to_spend(
                db.off_chain.coins_to_spend_index(&owner, &asset_id),
                total_amount,
                max,
                &excluded,
                db.batch_size,
            )
            .await?,
        )
        .yield_each(db.batch_size);

        let mut coins_per_asset = vec![];
        for coin_or_message_id in into_coin_id(selected_stream, max as usize).await? {
            let coin_type = match coin_or_message_id {
                coins::CoinId::Utxo(utxo_id) => {
                    db.coin(utxo_id).map(|coin| CoinType::Coin(coin.into()))?
                }
                coins::CoinId::Message(nonce) => {
                    let message = db.message(&nonce)?;
                    let message_coin: message_coin::MessageCoin = message.try_into()?;
                    CoinType::MessageCoin(message_coin.into())
                }
            };

            coins_per_asset.push(coin_type);
        }

        if coins_per_asset.is_empty() {
            return Err(CoinsQueryError::InsufficientCoinsForTheMax {
                asset_id,
                collected_amount: total_amount,
                max,
            }
            .into())
        }
        all_coins.push(coins_per_asset);
    }
    Ok(all_coins)
}

async fn coins_to_spend_without_cache(
    owner: fuel_tx::Address,
    query_per_asset: Vec<SpendQueryElementInput>,
    excluded_ids: Option<ExcludeInput>,
    max_input: u16,
    base_asset_id: &fuel_tx::AssetId,
    db: &ReadView,
) -> async_graphql::Result<Vec<Vec<CoinType>>> {
    let query_per_asset = query_per_asset
        .into_iter()
        .map(|e| {
            AssetSpendTarget::new(
                e.asset_id.0,
                e.amount.0,
                e.max
                    .and_then(|max| u16::try_from(max.0).ok())
                    .unwrap_or(max_input)
                    .min(max_input),
            )
        })
        .collect_vec();
    let excluded_ids: Option<Vec<_>> = excluded_ids.map(|exclude| {
        let utxos = exclude
            .utxos
            .into_iter()
            .map(|utxo| coins::CoinId::Utxo(utxo.into()));
        let messages = exclude
            .messages
            .into_iter()
            .map(|message| coins::CoinId::Message(message.into()));
        utxos.chain(messages).collect()
    });

    let spend_query =
        SpendQuery::new(owner, &query_per_asset, excluded_ids, *base_asset_id)?;

    let all_coins = random_improve(db, &spend_query)
        .await?
        .into_iter()
        .map(|coins| {
            coins
                .into_iter()
                .map(|coin| match coin {
                    coins::CoinType::Coin(coin) => CoinType::Coin(coin.into()),
                    coins::CoinType::MessageCoin(coin) => {
                        CoinType::MessageCoin(coin.into())
                    }
                })
                .collect_vec()
        })
        .collect();

    Ok(all_coins)
}

async fn select_coins_to_spend(
    CoinsToSpendIndexIter {
        big_coins_iter,
        dust_coins_iter,
    }: CoinsToSpendIndexIter<'_>,
    total: u64,
    max: u16,
    excluded_ids: &ExcludedKeysAsBytes,
    batch_size: usize,
) -> StorageResult<Vec<CoinsToSpendIndexEntry>> {
    if total == 0 && max == 0 {
        return Ok(vec![]);
    }

    let big_coins_stream = futures::stream::iter(big_coins_iter).yield_each(batch_size);
    let dust_coins_stream = futures::stream::iter(dust_coins_iter).yield_each(batch_size);

    let (selected_big_coins_total, selected_big_coins) =
        big_coins(big_coins_stream, total, max, excluded_ids).await?;

    if selected_big_coins_total < total {
        return Ok(vec![]);
    }
    let Some(last_selected_big_coin) = selected_big_coins.last() else {
        // Should never happen.
        return Ok(vec![]);
    };

    let number_of_big_coins: u16 = selected_big_coins
        .len()
        .try_into()
        .map_err(anyhow::Error::from)?;

    let max_dust_count = max_dust_count(max, number_of_big_coins);
    let (dust_coins_total, selected_dust_coins) = dust_coins(
        dust_coins_stream,
        last_selected_big_coin,
        max_dust_count,
        excluded_ids,
    )
    .await?;
    let retained_big_coins_iter =
        skip_big_coins_up_to_amount(selected_big_coins, dust_coins_total);

    Ok((retained_big_coins_iter.chain(selected_dust_coins)).collect())
}

async fn big_coins(
    big_coins_stream: impl Stream<Item = StorageResult<CoinsToSpendIndexEntry>> + Unpin,
    total: u64,
    max: u16,
    excluded_ids: &ExcludedKeysAsBytes,
) -> StorageResult<(u64, Vec<CoinsToSpendIndexEntry>)> {
    select_coins_until(big_coins_stream, max, excluded_ids, |_, total_so_far| {
        total_so_far >= total
    })
    .await
}

async fn dust_coins(
    dust_coins_stream: impl Stream<Item = StorageResult<CoinsToSpendIndexEntry>> + Unpin,
    last_big_coin: &CoinsToSpendIndexEntry,
    max_dust_count: u16,
    excluded_ids: &ExcludedKeysAsBytes,
) -> StorageResult<(u64, Vec<CoinsToSpendIndexEntry>)> {
    select_coins_until(
        dust_coins_stream,
        max_dust_count,
        excluded_ids,
        |coin, _| coin == last_big_coin,
    )
    .await
}

async fn select_coins_until<F>(
    mut coins_stream: impl Stream<Item = StorageResult<CoinsToSpendIndexEntry>> + Unpin,
    max: u16,
    excluded_ids: &ExcludedKeysAsBytes,
    predicate: F,
) -> StorageResult<(u64, Vec<CoinsToSpendIndexEntry>)>
where
    F: Fn(&CoinsToSpendIndexEntry, u64) -> bool,
{
    let mut coins_total_value: u64 = 0;
    let mut count = 0;
    let mut coins = Vec::with_capacity(max as usize);
    while let Some(coin) = coins_stream.next().await {
        let coin = coin?;
        if !is_excluded(&coin, excluded_ids)? {
            if count >= max || predicate(&coin, coins_total_value) {
                break;
            }
            count = count.saturating_add(1);
            let amount = coin.0.amount();
            coins_total_value = coins_total_value.saturating_add(amount);
            coins.push(coin);
        }
    }
    Ok((coins_total_value, coins))
}

fn is_excluded(
    (key, coin_type): &CoinsToSpendIndexEntry,
    excluded_ids: &ExcludedKeysAsBytes,
) -> StorageResult<bool> {
    match coin_type {
        IndexedCoinType::Coin => {
            let foreign_key = CoinOrMessageIdBytes::Coin(
                key.foreign_key_bytes()
                    .as_slice()
                    .try_into()
                    .map_err(StorageError::from)?,
            );
            Ok(excluded_ids.coins().contains(&foreign_key))
        }
        IndexedCoinType::Message => {
            let foreign_key = CoinOrMessageIdBytes::Message(
                key.foreign_key_bytes()
                    .as_slice()
                    .try_into()
                    .map_err(StorageError::from)?,
            );
            Ok(excluded_ids.messages().contains(&foreign_key))
        }
    }
}

fn max_dust_count(max: u16, big_coins_len: u16) -> u16 {
    let mut rng = rand::thread_rng();
    rng.gen_range(0..=max.saturating_sub(big_coins_len))
}

fn skip_big_coins_up_to_amount(
    big_coins: impl IntoIterator<Item = CoinsToSpendIndexEntry>,
    mut dust_coins_total: u64,
) -> impl Iterator<Item = CoinsToSpendIndexEntry> {
    big_coins.into_iter().skip_while(move |item| {
        let amount = item.0.amount();
        dust_coins_total
            .checked_sub(amount)
            .map(|new_value| {
                dust_coins_total = new_value;
                true
            })
            .unwrap_or_default()
    })
}

async fn into_coin_id(
    mut selected_stream: impl Stream<Item = CoinsToSpendIndexEntry> + Unpin,
    max_coins: usize,
) -> Result<Vec<CoinId>, StorageError> {
    let mut coins = Vec::with_capacity(max_coins);
    while let Some((foreign_key, coin_type)) = selected_stream.next().await {
        let coin = match coin_type {
            IndexedCoinType::Coin => {
                let bytes: [u8; COIN_FOREIGN_KEY_LEN] = foreign_key
                    .foreign_key_bytes()
                    .as_slice()
                    .try_into()
                    .map_err(StorageError::from)?;

                let (tx_id_bytes, output_index_bytes) = bytes.split_at(TxId::LEN);
                let tx_id = TxId::try_from(tx_id_bytes).map_err(StorageError::from)?;
                let output_index = u16::from_be_bytes(
                    output_index_bytes.try_into().map_err(StorageError::from)?,
                );
                CoinId::Utxo(fuel_tx::UtxoId::new(tx_id, output_index))
            }
            IndexedCoinType::Message => {
                let bytes: [u8; MESSAGE_FOREIGN_KEY_LEN] = foreign_key
                    .foreign_key_bytes()
                    .as_slice()
                    .try_into()
                    .map_err(StorageError::from)?;
                let nonce = fuel_types::Nonce::from(bytes);
                CoinId::Message(nonce)
            }
        };
        coins.push(coin);
    }
    Ok(coins)
}

#[cfg(test)]
mod tests {
    use fuel_core_storage::{
        codec::primitive::utxo_id_to_bytes,
        iter::IntoBoxedIter,
        Result as StorageResult,
    };
    use fuel_core_types::{
        entities::coins::coin::Coin,
        fuel_tx::{
            TxId,
            UtxoId,
        },
    };

    use crate::{
        graphql_api::{
            indexation::coins_to_spend::IndexedCoinType,
            ports::CoinsToSpendIndexIter,
            storage::coins::CoinsToSpendIndexKey,
        },
        schema::coins::{
            select_coins_to_spend,
            CoinOrMessageIdBytes,
            ExcludedKeysAsBytes,
        },
    };

    use super::{
        select_coins_until,
        CoinsToSpendIndexEntry,
    };

    const BATCH_SIZE: usize = 1;

    fn setup_test_coins(
        coins: impl IntoIterator<Item = u8>,
    ) -> Vec<Result<CoinsToSpendIndexEntry, fuel_core_storage::Error>> {
        let coins: Vec<StorageResult<_>> = coins
            .into_iter()
            .map(|i| {
                let tx_id: TxId = [i; 32].into();
                let output_index = i as u16;
                let utxo_id = UtxoId::new(tx_id, output_index);

                let coin = Coin {
                    utxo_id,
                    owner: Default::default(),
                    amount: i as u64,
                    asset_id: Default::default(),
                    tx_pointer: Default::default(),
                };

                let entry = (
                    CoinsToSpendIndexKey::from_coin(&coin),
                    IndexedCoinType::Coin,
                );
                Ok(entry)
            })
            .collect();
        coins
    }

    #[tokio::test]
    async fn select_coins_until_respects_max() {
        // Given
        const MAX: u16 = 3;

        let coins = setup_test_coins([1, 2, 3, 4, 5]);

        let excluded = ExcludedKeysAsBytes::new(vec![], vec![]);

        // When
        let result =
            select_coins_until(futures::stream::iter(coins), MAX, &excluded, |_, _| {
                false
            })
            .await
            .expect("should select coins");

        // Then
        assert_eq!(result.0, 1 + 2 + 3); // Limit is set at 3 coins
        assert_eq!(result.1.len(), 3);
    }

    #[tokio::test]
    async fn select_coins_until_respects_excluded_ids() {
        // Given
        const MAX: u16 = u16::MAX;

        let coins = setup_test_coins([1, 2, 3, 4, 5]);

        // Exclude coin with amount '2'.
        let excluded_coin_bytes = {
            let tx_id: TxId = [2; 32].into();
            let output_index = 2;
            let utxo_id = UtxoId::new(tx_id, output_index);
            CoinOrMessageIdBytes::Coin(utxo_id_to_bytes(&utxo_id))
        };
        let excluded = ExcludedKeysAsBytes::new(vec![excluded_coin_bytes], vec![]);

        // When
        let result =
            select_coins_until(futures::stream::iter(coins), MAX, &excluded, |_, _| {
                false
            })
            .await
            .expect("should select coins");

        // Then
        assert_eq!(result.0, 1 + 3 + 4 + 5); // '2' is skipped.
        assert_eq!(result.1.len(), 4);
    }

    #[tokio::test]
    async fn select_coins_until_respects_predicate() {
        // Given
        const MAX: u16 = u16::MAX;
        const TOTAL: u64 = 7;

        let coins = setup_test_coins([1, 2, 3, 4, 5]);

        let excluded = ExcludedKeysAsBytes::new(vec![], vec![]);

        let predicate: fn(&CoinsToSpendIndexEntry, u64) -> bool =
            |_, total| total > TOTAL;

        // When
        let result =
            select_coins_until(futures::stream::iter(coins), MAX, &excluded, predicate)
                .await
                .expect("should select coins");

        // Then
        assert_eq!(result.0, 1 + 2 + 3 + 4); // Keep selecting until total is greater than 7.
        assert_eq!(result.1.len(), 4);
    }

    #[tokio::test]
    async fn already_selected_big_coins_are_never_reselected_as_dust() {
        // Given
        const MAX: u16 = u16::MAX;
        const TOTAL: u64 = 101;

        let big_coins_iter = setup_test_coins([100, 4, 3, 2]).into_iter().into_boxed();
        let dust_coins_iter = setup_test_coins([100, 4, 3, 2])
            .into_iter()
            .rev()
            .into_boxed();
        let coins_to_spend_iter = CoinsToSpendIndexIter {
            big_coins_iter,
            dust_coins_iter,
        };

        let excluded = ExcludedKeysAsBytes::new(vec![], vec![]);

        // When
        let result =
            select_coins_to_spend(coins_to_spend_iter, TOTAL, MAX, &excluded, BATCH_SIZE)
                .await
                .expect("should select coins");

        let mut results = result
            .into_iter()
            .map(|(key, _)| key.amount())
            .collect::<Vec<_>>();

        // Then

        // Because we select a total of 101, first two coins should always selected (100, 4).
        let expected = vec![100, 4];
        let actual: Vec<_> = results.drain(..2).collect();
        assert_eq!(expected, actual);

        // The number of dust coins is selected randomly, so we might have:
        // - 0 dust coins
        // - 1 dust coin [2]
        // - 2 dust coins [2, 3]
        // Even though in majority of cases we will have 2 dust coins selected (due to
        // MAX being huge), we can't guarantee that, hence we assert against all possible cases.
        // The important fact is that neither 100 nor 4 are selected as dust coins.
        let expected_1: Vec<u64> = vec![];
        let expected_2: Vec<u64> = vec![2];
        let expected_3: Vec<u64> = vec![2, 3];
        let actual: Vec<_> = std::mem::take(&mut results);

        assert!(
            actual == expected_1 || actual == expected_2 || actual == expected_3,
            "Unexpected dust coins: {:?}",
            actual,
        );
    }

    #[tokio::test]
    async fn selection_algorithm_should_bail_on_error() {
        // Given
        const MAX: u16 = u16::MAX;
        const TOTAL: u64 = 101;

        let mut coins = setup_test_coins([10, 9, 8, 7]);
        let error = fuel_core_storage::Error::NotFound("S1", "S2");

        let first_2: Vec<_> = coins.drain(..2).collect();
        let last_2: Vec<_> = std::mem::take(&mut coins);

        let excluded = ExcludedKeysAsBytes::new(vec![], vec![]);

        // Inject an error into the middle of coins.
        let coins: Vec<_> = first_2
            .into_iter()
            .take(2)
            .chain(std::iter::once(Err(error)))
            .chain(last_2)
            .collect();
        let coins_to_spend_iter = CoinsToSpendIndexIter {
            big_coins_iter: coins.into_iter().into_boxed(),
            dust_coins_iter: std::iter::empty().into_boxed(),
        };

        // When
        let result =
            select_coins_to_spend(coins_to_spend_iter, TOTAL, MAX, &excluded, BATCH_SIZE)
                .await;

        // Then
        assert!(
            matches!(result, Err(error) if error == fuel_core_storage::Error::NotFound("S1", "S2"))
        );
    }
}
